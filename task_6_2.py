"""
Задание 2.
Попытайтесь выполнить профилирование памяти в любом скрипте с рекурсией.
Вам нужно обнаружить проблему в процессе этого. Но проблема связана не с тем,
что рекурсия потребляет много памяти, а с самим процессом замеров.
Опищите эту проблему и найдите простой путь ее решения.
Опишите этот путь и покажите его применение
"""

from memory_profiler import profile

"""
Взята функция even_and_odd() из домашнего задания 2, упражнения 2.
Функция подсчитывает четные и нечетные цифры введенного натурального числа, используя рекурсию.
"""


@profile
def wrapper(w_number):
    def even_and_odd(my_number, even=0, odd=0):
        if my_number != 0:
            remainder = my_number % 10
            if remainder % 2 == 0:
                even += 1
            else:
                odd += 1
            return even_and_odd(my_number // 10, even, odd)
        else:
            print(f'Количество четных цифр во введенном числе - {even}, нечетных - {odd}')
    return even_and_odd(w_number)


number = int(input('Введите число для подсчета четных и нечетных цифр: \n'))
wrapper(number)

"""
При попытке профилирования рекурсивной функции, происходит срабатывание декоратора @profile столько раз, сколько 
вызывается функция - один раз при первом вызове функции и каждый раз, когда функция вызывает сама себя через рекурсию.
Это не дает никакой дополнительной информации и просто засоряет вывод, особенно если глубина рекурсии достаточно
велика. Чтобы этого избежать - достаточно просто размечать декоратор @profile не на саму функцию, а на отдельную
обертку, которая запустится всего один раз, передав результаты функции на профилирование.
"""