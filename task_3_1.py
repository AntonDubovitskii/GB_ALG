"""
Задание 1.
Реализуйте функции:
a) заполнение списка, оцените сложность в O-нотации
   заполнение словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
b) получение элемента списка, оцените сложность в O-нотации
   получение элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
с) удаление элемента списка, оцените сложность в O-нотации
   удаление элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

from time import perf_counter


def time_prof(func):
    def wrapper(*args, **kwargs):
        start = perf_counter()
        function_result = func(*args, **kwargs)
        print(f'Выполнено за: {(perf_counter() - start)} секунд')
        return function_result
    return wrapper


# Здесь и далее работа функций искусственно замедляется циклом, чтобы данные были более репрезентативными
# Часть а) - заполнение:

@time_prof
def list_filling(mylist):
    """
    Сложность: O(1).
    """
    for elem in range(0, 1000000):    # O(1)
        mylist.append(elem)           # O(1)


@time_prof
def dict_filling(mydict):
    """
    Сложность: O(1).
    """
    for i in range(0, 1000000):       # O(1)
        mydict[i] = i                 # O(1)
    return mydict

# Часть b) - получение элемента:


@time_prof
def list_get_elem(mylist):
    """
    Сложность: O(1).
    """
    for i in range(0, 1000000):       # O(1)
        return mylist[i]              # O(1)


@time_prof
def dict_get_value(mydict):
    """
    Сложность: O(1).
    """
    for i in range(0, 1000000):       # O(1)
        return mydict[i]              # O(1)

# Часть с) - удаление элемента:


@time_prof
def list_elem_del(mylist):
    """
    Сложность: O(N).
    """
    for i in range(0, 10000):     # O(1)
        mylist.pop(i)             # O(N)


@time_prof
def dict_elem_del(mydict):
    """
    Сложность: O(1).
    """
    for i in range(0, 10000):     # O(1)
        mydict.pop(i, None)       # O(1)


if __name__ == '__main__':

    testlist = []
    testdict = {}

    ###################################################################################################################
    list_filling(testlist)   # Выполнено за: 0.0660088062286377 секунд
    dict_filling(testdict)   # Выполнено за: 0.07300162315368652 секунд

    # Заполнение списка происходит немного быстрее, так как при заполнении словаря необходимо хешировать ключи.

    ###################################################################################################################
    list_get_elem(testlist)   # Выполнено за: 5.800000508315861e-06 секунд
    dict_get_value(testdict)  # Выполнено за: 1.7999991541728377e-06 секунд
    """
    Получение элемента словаря происходит более чем в 3 раза быстрее, благодаря эффективности нахождения элемента по 
    ключу.
    """
    ###################################################################################################################
    list_elem_del(testlist)  # Выполнено за: 9.559657800011337 секунд
    dict_elem_del(testdict)  # Выполнено за: 0.0009244999964721501 секунд

    """
    Удаление элемента из словаря происходит намного быстрее, так как при удалении элемента списка происходит сдвиг всех
    остальных элементов на одну позицию. Разница тем заметнее, чем больше элементов содержит список. Последовательное 
    удаление 10000 элементов из списка, состоящего из миллиона элементов, заняло более 9.5 секунд, 
    в то же время удаление 10000 значений по ключу из словаря произошло практически мгновенно - за 0.0009 секунды. 
    Разница в 10380 раз.
    """

