"""
Задание 3.
Для этой задачи
1) придумайте 2-3 решения (обязательно с различной сложностью)
2) оцените сложность каждого выражения в этих решениях в нотации О-большое
3) оцените итоговую сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему
Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""

company_info_dict = {'Walmart': 571960, 'Apple': 365820, 'UnitedHealth Group': 279320, 'Chevron': 135140,
                     'Daimler': 188440, 'Toyota': 291560}

"""
Функция принимает словарь, содержащий пары название компании - доход, после чего возвращает словарь, содержащий 
три компании с наибольшим доходом.

Алгоритм 1:
Функция принимающая словарь и при помощи функции sorted() образует сортированный список, ограниченный срезом. На его
основании строится новый словарь, соответствующий условиям задания.

Cложность: O(NlogN).
"""


def highest_income1(info: dict):
    result_list = sorted(info, key=info.get, reverse=True)[:3]                                           # O(NlogN)
    result_dict = {result_list[0]: info.get(result_list[0]), result_list[1]: info.get(result_list[1]),
                   result_list[2]: info.get(result_list[2])}                                             # O(1)
    return result_dict                                                                                   # 0(1)


"""
Функция принимает словарь, содержащий пары название компании - доход, после чего возвращает словарь, содержащий 
три компании с наибольшим доходом.

Алгоритм 2:
Совершается проход по ключам и значениям переданного словаря, во время которого при помощи логических условий выбираются
три наибольших значения, каждое из которых, а также их ключи, записываются в отдельные переменные. При помощи них
формируется новый словарь, отвечающий условиям задания. Алгоритмическая сложность меньше чем у первого алгоритма,
но код значительно более громоздкий и топорный, поэтому в большинстве случаев предпочтительнее первый алгоритм.

Cложность: O(N).
"""


def highest_income2(info: dict):
    first_key = ''
    second_key = ''
    third_key = ''
    first_value = 0
    second_value = 0
    third_value = 0

    for key, value in info.items():                     # O(N)
        if value > first_value:                         # O(1)
            first_key = key
            first_value = value
        elif first_value > value > second_value:        # O(1)
            second_value = value
            second_key = key
        elif second_value > value > third_value:        # O(1)
            third_value = value
            third_key = key
    return {first_key: first_value, second_key: second_value, third_key: third_value}    # O(1)


print(highest_income1(company_info_dict))
print(highest_income2(company_info_dict))

