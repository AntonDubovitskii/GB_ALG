"""
Задание 1.
Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python
На каждый скрипт нужно два решения - исходное и оптимизированное.
Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.

Это файл для пятого скрипта
"""
from memory_profiler import memory_usage

"""
Взята функция even_and_odd() из домашнего задания 2, упражнения 2.
Функция подсчитывает четные и нечетные цифры введенного натурального числа, используя рекурсию.
"""


def memory(func):
    def wrapper(*args, **kwargs):
        m1 = memory_usage()
        res = func(*args)
        m2 = memory_usage()
        mem_diff = m2[0] - m1[0]
        print(f"Выполнение заняло {mem_diff} Mib")
        return res

    return wrapper


@memory
def wrapper(w_number):
    def even_and_odd(my_number, even=0, odd=0):
        if my_number != 0:
            remainder = my_number % 10
            if remainder % 2 == 0:
                even += 1
            else:
                odd += 1
            return even_and_odd(my_number // 10, even, odd)
        else:
            print(f'Количество четных цифр во введенном числе - {even}, нечетных - {odd}')

    return even_and_odd(w_number)


@memory
def even_and_odd_cycle(my_number):
    even = 0
    odd = 0
    for i in map(int, str(my_number)):
        if i % 2 == 0:
            even += 1
        else:
            odd += 1
    print(f'Количество четных цифр во введенном числе - {even}, нечетных - {odd}')


number = int(input('Введите число для подсчета четных и нечетных цифр: \n'))
wrapper(number)
even_and_odd_cycle(number)

"""
Количество четных цифр во введенном числе - 32, нечетных - 20
Выполнение заняло 0.01953125 Mib
Количество четных цифр во введенном числе - 32, нечетных - 20
Выполнение заняло 0.0 Mib

Вывод:

Для оптимизации скрипта рекурсия была заменена на цикл, передаваемое в функцию число приводится к строке, а затем,
при помощи map(), каждый элемент приводится к типу int. Таким образом получается итерируемый объект, по которому
можно пройтись при помощи цикла и проверить каждое число в нем. Результаты профилирования показывают, что данный
способ эффективнее по затратам памяти, чем рекурсия, особенно если введено большое число.
"""

